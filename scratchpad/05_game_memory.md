# Game Memory Module

> **Schema Alignment Reminder:** The authoritative contract for engine turns and scene persistence lives in `config/game_engine_schema.json`. The TinyDB helpers do not enforce this schema at runtime, so every architectural or implementation change **must be cross-checked against that file** before code is written.

- Initializes and incrementally builds memory structures reflecting game meta-progress.
- Tracks player sessions, using default or updated player names.
- Stores persistent game object memory and meta-progress using TinyDB.
- Heuristically parses game controller inputs into structured memory of game elements.
- Reads AI buddy memory structure JSON to shape memory schemas.
- Prepares prompts for AI structured-output inference and narration inference.
- Parses AI streaming outputs into game memory structures.

## Scene Object

Define a `Scene` class to persist enrich metadata from `EngineTurn` data and persist accumulative state artifacts between turns.
Implement DRY code that canonically leverages well defined structures.

Fields:
- `room_name`: string name of the EngineTurns persisted in this Scene
- `description_lines`: array of strings — an accumulative, non-duplicative list of lines appearing in `EngineTurn.description`. New lines are appended only if not already present.
- `sceneItems`:  an accumulative, non-duplicative list of seen in-game objects
- `currentItems`: list of current in-game objects as it last ended/resulted within this Scene
- `sceneActions`: an accumulative, non-duplicative list of commands and results occuring in this Scene. For example on room changing actions, should include the command/way of exit
- `actionRecords`: structured history of every player command observed in this scene. Each record contains the turn number, command text, normalized result summary, category (`movement` or `interaction`), parsed verb, and an optional `target_item`. The TinyDB store uses these canonical records to drive downstream world-state and inventory updates when the engine transcript does not emit fresh `visible_items` or `player_state.inventory` data.
- `sceneIntroCollection`: a collection of objects with: the previous room name(s), move number(s) and command/action(s) that have taken the player into this Scene *from the previous*
- `NPCs`: an accumulative, non-duplicative list of NPC names seen in this Scene

AI Inferred fields:
- `Narrations`: array of strings — an accumulative, non-duplicative list of previous Narrations generated by the AI completions engine. New lines are appended only if not already present.
- TBD

Responsibilities:
- Instantiate a `Scene` from the first `EngineTurn` appearance
- extracting and persisting memory fields on subsequent appearances including additional turns in the same room
- Maintain `description_lines` as a running union of narrative lines, avoiding duplicates.
- Provide serialization/deserialization to the TinyDB store.
- Store, Update and Retrieve in-databse persistance of the Scene

### ActionRecord structure

`ActionRecord` instances are emitted once per turn and stored alongside the textual `sceneActions` list. They serve as the authoritative, schema-aligned explanation of what the player attempted and what the engine reported back. Fields:

- `turn`: absolute turn number within the session, so downstream systems can correlate actions with other telemetry.
- `command`: the original player input.
- `result`: normalized summary used for prompt context and auditing.
- `category`: `movement` or `interaction`, determined by whether the room changed.
- `verb`: the parsed root verb (`take`, `drop`, `look`, etc.) that higher-level systems can key off without reparsing the transcript.
- `target_item`: optional string pointing to the object of the command (e.g., `leaflet`).

`category` values:

- `movement`: the action moved the player to a different room.
- `item_interaction`: canonical indicator that the action manipulates an inventory/world object (e.g., `take`, `drop`, `put`). Memory uses this to update `scene_items`, `current_items`, and the persisted player inventory even when the engine omits `visible_items` from the transcript.
- `world_object_interaction`: verbs like `open`, `close`, `look`, or `examine` that interact with the environment but may not immediately change inventory.
- `generic_interaction`: everything else; retained for completeness so analytics can bucket miscellaneous commands.

Consumers should treat `actionRecords` as the canonical source when updating UI trees, reconstructing inventory timelines, or replaying state transitions. The legacy `sceneActions` string list remains for backward compatibility with older prompts, but new integrations must prefer the structured records to avoid heuristic drift.

> **Limitations:** Multi-step commands such as “take the nest and climb tree” arrive as a single transcript chunk. Because the runtime classifies the entire command by the dominant effect (movement if the room changes), the resulting `ActionRecord` may be tagged `movement` and the embedded `take` verb will never exercise the item-interaction logic. Until the LLM parsing layer is implemented, we treat these composite commands as best-effort hints only: items may stay in their previous state even though the transcript says they were manipulated, and follow-up scenes must rely on future turns (or manual correction) to reconcile the state.

## Workflow

1. Receive `EngineTurn` from `GameAPI`.
2. Create a new `Scene` or update existing scene for the current room.
3. Append, update
4. Persist updated `Scene` to the database.
5. Use `Scene` memory when building AI prompts or UI updates.
6. **Trigger order matters** — memory assessment/insertion must complete *before* the next prompt is constructed so the LLM receives the live state for the current turn. Narrations can append immediately afterwards.

### Turn semantics
- **Turn N completion**: occurs when the game engine finishes responding to the player command and the controller parses the resulting `EngineTurn`. At this point we must run `GameMemoryStore.record_turn(...)` so the memory reflects turn N state before we call `get_context_for_prompt()` for turn N narration.
- **Prompt for turn N+1**: is built using the updated memory from turn N. The narration added after the LLM completes is still tied to turn N, but it does not form the context for turn N+1 until after it has been appended to the scene.
- **Implications**: any log/transaction events (TinyDB writes, JSONL memory log entries) should happen as soon as the engine facts are parsed, not when the narration arrives. This makes the prompt deterministic, avoids race conditions, and keeps the welcome turn aligned with the first prompt.