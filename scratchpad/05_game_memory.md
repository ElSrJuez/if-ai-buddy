# Game Memory Module

- Initializes and incrementally builds memory structures reflecting game meta-progress.
- Tracks player sessions, using default or updated player names.
- Stores persistent game object memory and meta-progress using TinyDB.
- Heuristically parses game controller inputs into structured memory of game elements.
- Reads AI buddy memory structure JSON to shape memory schemas.
- Prepares prompts for AI structured-output inference and narration inference.
- Parses AI streaming outputs into game memory structures.

## Scene Object

Define a `Scene` class to persist enrich metadata from `EngineTurn` data and persist accumulative state artifacts between turns.
Implement DRY code that canonically leverages well defined structures.

Fields:
- `room_name`: string name of the EngineTurns persisted in this Scene
- `description_lines`: array of strings — an accumulative, non-duplicative list of lines appearing in `EngineTurn.description`. New lines are appended only if not already present.
- `sceneItems`:  an accumulative, non-duplicative list of seen in-game objects
- `currentItems`: list of current in-game objects as it last ended/resulted within this Scene
- `sceneActions`: an accumulative, non-duplicative list of commands and results occuring in this Scene. For example on room changing actions, should include the command/way of exit
- `sceneIntroCollection`: a collection of objects with: the previous room name(s), move number(s) and command/action(s) that have taken the player into this Scene *from the previous*
- `NPCs`: an accumulative, non-duplicative list of NPC names seen in this Scene

AI Inferred fields:
- `Narrations`: array of strings — an accumulative, non-duplicative list of previous Narrations generated by the AI completions engine. New lines are appended only if not already present.
- TBD

Responsibilities:
- Instantiate a `Scene` from the first `EngineTurn` appearance
- extracting and persisting memory fields on subsequent appearances including additional turns in the same room
- Maintain `description_lines` as a running union of narrative lines, avoiding duplicates.
- Provide serialization/deserialization to the TinyDB store.
- Store, Update and Retrieve in-databse persistance of the Scene

## Workflow

1. Receive `EngineTurn` from `GameAPI`.
2. Create a new `Scene` or update existing scene for the current room.
3. Append, update
4. Persist updated `Scene` to the database.
5. Use `Scene` memory when building AI prompts or UI updates.
6. **Trigger order matters** — memory assessment/insertion must complete *before* the next prompt is constructed so the LLM receives the live state for the current turn. Narrations can append immediately afterwards.

### Turn semantics
- **Turn N completion**: occurs when the game engine finishes responding to the player command and the controller parses the resulting `EngineTurn`. At this point we must run `GameMemoryStore.record_turn(...)` so the memory reflects turn N state before we call `get_context_for_prompt()` for turn N narration.
- **Prompt for turn N+1**: is built using the updated memory from turn N. The narration added after the LLM completes is still tied to turn N, but it does not form the context for turn N+1 until after it has been appended to the scene.
- **Implications**: any log/transaction events (TinyDB writes, JSONL memory log entries) should happen as soon as the engine facts are parsed, not when the narration arrives. This makes the prompt deterministic, avoids race conditions, and keeps the welcome turn aligned with the first prompt.